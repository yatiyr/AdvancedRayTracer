#version 460

layout (local_size_x = 1, local_size_y = 1) in;
layout (rgba32f, binding = 0) uniform image2D imgOutput;


/* SSBO will be added like this
layout(std430, binding=3) buffer layoutName
{
	float eren[];
};

*/

// ------------------------ STRUCTS ----------------------------- //
struct PointLight
{
	vec3 position;
	vec3 intensity;
};

struct Material
{
	vec3 ambientReflectance;
	vec3 diffuseReflectance;
	vec3 specularReflectance;
	vec3 mirrorReflectance;
	float phongExponent;
};

struct Vertex
{
	vec3 pos;
};

struct Indices
{
	int a;
	int b;
	int c;
};

struct Triangle
{
	int materialId;
	Indices indices;
};

struct Mesh
{
	int materialId;
	int indicesOffset;
	int indicesSize;
};

struct Sphere
{
	int centerVertexId;
	int materialId;
	float radius;
};

struct Camera
{
	vec3 position;
	vec3 gaze;
	vec3 up;
	vec4 nearPlane;
	vec2 imageResolution;
	float nearDistance;
};

// -------------------------------------------------------------- //


// ------------------- UNIFORMS -------------------------- //

uniform vec3 backgroundColor;
uniform vec3 ambientLight;
uniform Camera camera;
uniform int maxRecursionDepth;
uniform float shadowRayEpsilon;
uniform float intersectionTestEpsilon;


uniform int lightCount;
uniform int materialCount;
uniform int vertexCount;
uniform int meshCount;
uniform int meshIndexCount;
uniform int triangleCount;
uniform int sphereCount;

// -------------------------------------------------------------- //

// -------------- SHADER STORAGE BUFFER OBJECTS ----------------- //

layout(std430, binding=3) buffer lights
{
	PointLight pointLights[];
};

layout(std430, binding=4) buffer mtrls
{
	Material materials[];
};

layout(std430, binding=5) buffer vrtxdata
{
	Vertex vertexData[];
};

layout(std430, binding=6) buffer mshs
{
	Mesh meshes[];
};

layout(std430, binding=7) buffer tris
{
	Triangle triangles[];
};

layout(std430, binding=8) buffer sphrs
{
	Sphere spheres[];
};

layout(std430, binding=9) buffer cmrs
{
	Camera cameras[];
};

layout(std430, binding=10) buffer mshIndices
{
	Indices meshIndexBuffer[];
};

// -------------------------------------------------------------- //

void main()
{
	ivec2 size = imageSize(imgOutput);

	// base pixel color for image
	vec4 pixel = vec4(0.0, 0.0, 0.0, 1.0);

	// get index in global work group i.e x,y position
	ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);

	if(pixelCoords.x == 0 && pixelCoords.y == size.y - 1)
	{
		pixel = vec4(vertexData[6].pos , 1.0);
	}

	//
	// TODO: IMPLEMENT HERE
	//

	// output to a specific pixel in the image
	imageStore(imgOutput, ivec2(pixelCoords.x, size.y - pixelCoords.y -1), pixel);
}