#version 460

layout (local_size_x = 1, local_size_y = 1) in;
layout (rgba32f, binding = 0) uniform image2D imgOutput;

// ------------------------ STRUCTS ----------------------------- //
struct PointLight
{
	vec3 position;
	vec3 intensity;
};

struct Material
{
	vec3 ambientReflectance;
	vec3 diffuseReflectance;
	vec3 specularReflectance;
	vec3 mirrorReflectance;
	float phongExponent;
};

struct Vertex
{
	vec3 pos;
};

struct Indices
{
	int a;
	int b;
	int c;
};

struct Triangle
{
	int materialId;
	Indices indices;
};

struct Mesh
{
	int materialId;
	int indicesOffset;
	int indicesSize;
};

struct Sphere
{
	int centerVertexId;
	int materialId;
	float radius;
};

struct Camera
{
	vec3 position;
	vec3 gaze;
	vec3 up;
	vec3 v;
	vec4 nearPlane;
	vec2 imageResolution;
	float nearDistance;
};


struct Ray
{
	vec3 origin;
	vec3 direction;
};

struct IntersectionReport
{
	vec3 intersection;
	vec3 normal;
	float d;
	int materialId;
};

// -------------------------------------------------------------- //
#define FLT_MAX 3.402823466e+38
#define FLT_MIN 1.175494351e-38
// ------------------- UNIFORMS -------------------------- //

uniform vec3 backgroundColor;
uniform vec3 ambientLight;
uniform Camera camera;
uniform int maxRecursionDepth;
uniform float shadowRayEpsilon;
uniform float intersectionTestEpsilon;


uniform int lightCount;
uniform int materialCount;
uniform int vertexCount;
uniform int meshCount;
uniform int meshIndexCount;
uniform int triangleCount;
uniform int sphereCount;

// -------------------------------------------------------------- //

// -------------- SHADER STORAGE BUFFER OBJECTS ----------------- //

layout(std430, binding=3) buffer lights
{
	PointLight pointLights[];
};

layout(std430, binding=4) buffer mtrls
{
	Material materials[];
};

layout(std430, binding=5) buffer vrtxdata
{
	Vertex vertexData[];
};

layout(std430, binding=6) buffer mshs
{
	Mesh meshes[];
};

layout(std430, binding=7) buffer tris
{
	Triangle triangles[];
};

layout(std430, binding=8) buffer sphrs
{
	Sphere spheres[];
};

layout(std430, binding=9) buffer cmrs
{
	Camera cameras[];
};

layout(std430, binding=10) buffer mshIndices
{
	Indices meshIndexBuffer[];
};

layout(std430, binding=11) buffer mshNormals
{
	Vertex meshNormals[];
};

// -------------------------------------------------------------- //

// -------------------------- GLOBALS --------------------------- //
/*
	if(fabs(someFloat - 1.0) < 0.000001)
	{

	}

*/

float tmin = 0;
float tmax = 1000;
// -------------------------------------------------------------- //


// -------------------- FUNCTIONS ------------------------------- //


Ray computePrimaryRay(ivec2 pixelCoords)
{

	Ray x;
	x.origin = camera.position;
	vec3 m = x.origin + camera.gaze * camera.nearDistance;
	vec3 q = m + camera.nearPlane.x * camera.v + camera.nearPlane.w * camera.up;

	float su = (pixelCoords.x + 0.5) * (camera.nearPlane.y - camera.nearPlane.x) / camera.imageResolution.x;
	float sv = (pixelCoords.y + 0.5) * (camera.nearPlane.w - camera.nearPlane.z) / camera.imageResolution.y;

	x.direction = normalize((q + su*camera.v - sv*camera.up) - x.origin);
	return x;
}

// This function tests intersection between a ray and a sphere
IntersectionReport intersectSphere(Ray r, Sphere s, float tmin, float tmax)
{
	IntersectionReport report;

	report.intersection = vec3(FLT_MIN);
	report.d = FLT_MAX;

	vec3 sphereCenter = vertexData[s.centerVertexId - 1].pos;

	float discriminant = pow(dot(r.direction, (r.origin - sphereCenter)),2) - 
	                     dot(r.direction,r.direction)*(dot(r.origin - sphereCenter, r.origin - sphereCenter) - 
						                               s.radius * s.radius);
	
	float t;

	if(discriminant >= 0)
	{
		float t1 = -(dot(r.direction, (r.origin - sphereCenter)) + sqrt(discriminant)) / dot(r.direction, r.direction);
		float t2 = -(dot(r.direction, (r.origin - sphereCenter)) - sqrt(discriminant)) / dot(r.direction, r.direction);

		t =  min(t1, t2);

		if(t > tmin && t < tmax)
		{
			report.d = t;
			report.intersection = r.origin + t*r.direction;
			report.materialId = s.materialId;
			report.normal = normalize(report.intersection - sphereCenter);
		}

		
		return report;
	}


	return report;
}

// This function tests intersection between a ray and a triangle
IntersectionReport intersectFace(Ray r, Indices indices, float tmin, float tmax)
{
	IntersectionReport report;
	report.intersection = vec3(FLT_MIN);
	report.d = FLT_MAX;	

	vec3 a = vertexData[indices.a - 1].pos;
	vec3 b = vertexData[indices.b - 1].pos;
	vec3 c = vertexData[indices.c - 1].pos;

	float detA = determinant(mat3(vec3(a.x - b.x, a.y - b.y, a.z - b.z),
	                              vec3(a.x - c.x, a.y - c.y, a.z - c.z),
								  vec3(r.direction.x, r.direction.y, r.direction.z)));


	float beta = determinant(mat3(vec3(a.x - r.origin.x, a.y - r.origin.y, a.z - r.origin.z),
	                              vec3(a.x - c.x, a.y - c.y, a.z - c.z),
								  vec3(r.direction.x, r.direction.y, r.direction.z)))/detA;

	float gamma = determinant(mat3(vec3(a.x - b.x, a.y - b.y, a.z - b.z),
	                               vec3(a.x - r.origin.x, a.y - r.origin.y, a.z - r.origin.z),
								   vec3(r.direction.x, r.direction.y, r.direction.z)))/detA;


	float t = determinant(mat3(vec3(a.x - b.x, a.y - b.y, a.z - b.z),
	                           vec3(a.x - c.x, a.y - c.y, a.z - c.z),
							   vec3(a.x - r.origin.x, a.y - r.origin.y, a.z - r.origin.z)))/detA;


	if((beta + gamma <= 1 + intersectionTestEpsilon) && (beta >= -intersectionTestEpsilon) && (gamma >= -intersectionTestEpsilon) && t>tmin && t<tmax)
	{
		report.d = t;
		report.intersection = r.origin + t*r.direction;		
	}

	return report;
}

IntersectionReport intersectTriangle(Ray r, Triangle triangle)
{
	IntersectionReport report = intersectFace(r, triangle.indices, tmin, tmax);
	report.materialId = triangle.materialId;

	vec3 a = vertexData[triangle.indices.a-1].pos;
	vec3 b = vertexData[triangle.indices.b-1].pos;
	vec3 c = vertexData[triangle.indices.c-1].pos;

	report.normal = normalize(cross(b-a, c-a));


	return report;
}

IntersectionReport intersectMesh(Ray r, Mesh mesh)
{
	float tMin = FLT_MAX;

	IntersectionReport report;
	report.intersection = vec3(FLT_MAX);
	report.d = tMin;	
	report.materialId = mesh.materialId;

	for(uint i= mesh.indicesOffset; i<mesh.indicesSize; i++)
	{
		IntersectionReport rprt = intersectFace(r, meshIndexBuffer[i], tmin, tmax);

		if(rprt.d < tMin)
		{
			report.intersection = rprt.intersection;
			report.normal = meshNormals[i].pos;
			report.d = rprt.d;
			tMin = report.d;
		}
	}


	return report;	
}

IntersectionReport testWorldIntersection(Ray primaryRay)
{
	float tMin = FLT_MAX;
	IntersectionReport report;
	report.intersection = vec3(FLT_MAX);
	report.d = FLT_MAX;	

	
	for(uint i=0; i<meshCount; i++)
	{
		IntersectionReport r = intersectMesh(primaryRay, meshes[i]);
		if(r.d < tMin)
		{
			report = r;
			tMin = r.d;
		}
	}
	

	
	for(uint i=0; i<triangleCount; i++)
	{
		IntersectionReport r = intersectTriangle(primaryRay, triangles[i]);
		if(r.d < tMin)
		{
			report = r;
			tMin = r.d;
		}		
	}
	
	
	
	for(uint i=0; i<sphereCount; i++)
	{
		IntersectionReport r = intersectSphere(primaryRay, spheres[i], tmin, tmax);
		if(r.d < tMin)
		{
			report = r;
			tMin = r.d;
		}
	}
	
	

	return report;
}

bool shadowRayIntersection(Ray ray, float dist)
{
	float tMin = FLT_MAX;
	IntersectionReport report;
	report.intersection = vec3(FLT_MAX);
	report.d = FLT_MAX;

	for(uint i=0; i<meshCount; i++)
	{
		IntersectionReport r = intersectMesh(ray, meshes[i]);
		if(r.d < dist)
		{
			return true;
		}
	}
	

	
	for(uint i=0; i<triangleCount; i++)
	{
		IntersectionReport r = intersectTriangle(ray, triangles[i]);
		if(r.d < dist)
		{
			return true;
		}		
	}
	
	
	
	for(uint i=0; i<sphereCount; i++)
	{
		IntersectionReport r = intersectSphere(ray, spheres[i], tmin, tmax);
		if(r.d < dist)
		{
			return true;
		}
	}

	return false;

}

vec3 computeAmbientComponent(IntersectionReport report)
{
	return ambientLight * materials[report.materialId - 1].ambientReflectance;
}

vec3 computeDiffuseComponent(IntersectionReport report, PointLight light)
{
	vec3 result = vec3(0.0);

	float lightDistance = length(light.position - report.intersection);
	vec3 wi = normalize(light.position - report.intersection);
	result += materials[report.materialId - 1].diffuseReflectance * 
		      max(0,dot(wi, report.normal)) * 
			  (light.intensity/(lightDistance*lightDistance));

	return result;
}

vec3 computeSpecularComponent(IntersectionReport report, Ray primaryRay, PointLight light)
{
	vec3 result = vec3(0.0);


	float lightDistance = length(light.position - report.intersection);		
	vec3 wi = normalize(light.position - report.intersection);
	vec3 h = normalize(wi - primaryRay.direction);

	result += materials[report.materialId - 1].specularReflectance *
		      pow(max(0, dot(report.normal, h)), materials[report.materialId -1].phongExponent) *
			  (light.intensity/(lightDistance*lightDistance));				  



	return result;
}

bool shadowTest(IntersectionReport report, PointLight light)
{
	Ray lightRay;

	lightRay.direction = normalize(light.position - report.intersection);
	lightRay.origin = report.intersection + shadowRayEpsilon*report.normal;

	float dist = length(light.position - report.intersection);


	return shadowRayIntersection(lightRay, dist);

}

vec3 computeFinalColor(IntersectionReport report, Ray primaryRay)
{
	vec3 result = computeAmbientComponent(report);

	for(uint i=0; i<lightCount; i++)
	{
		if(shadowTest(report, pointLights[i]))
		{
			continue;
		}
		else
		{
			result += computeDiffuseComponent(report, pointLights[i]) + 
			          computeSpecularComponent(report, primaryRay, pointLights[i]);
		}
	}

	return clamp(result, vec3(0.0), vec3(1.0));
}


// -------------------------------------------------------------- //
void main()
{
	ivec2 size = imageSize(imgOutput);

	// base pixel color for image
	vec4 pixel = vec4(backgroundColor, 1.0);

	// get index in global work group i.e x,y position
	ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);

	Ray primaryRay = computePrimaryRay(pixelCoords);
	IntersectionReport report = testWorldIntersection(primaryRay);


	if(report.d != FLT_MAX)
	{


		pixel = vec4(computeFinalColor(report, primaryRay), 1.0);
	}
	else
	{
		pixel = vec4(backgroundColor, 1.0);
	}

	
	if(pixelCoords.x == 280 && pixelCoords.y == size.y - 230)
	{



		//pixel = vec4(lightRay.origin, 1.0);

	}
	

	//
	// TODO: IMPLEMENT HERE
	//

	// output to a specific pixel in the image
	imageStore(imgOutput, ivec2(pixelCoords.x, size.y - pixelCoords.y -1), pixel);
}