#version 460

layout (local_size_x = 1, local_size_y = 1) in;
layout (rgba32f, binding = 0) uniform image2D imgOutput;

// ------------------------ STRUCTS ----------------------------- //
struct PointLight
{
	vec3 position;
	vec3 intensity;
};

struct Material
{
	vec3 ambientReflectance;
	vec3 diffuseReflectance;
	vec3 specularReflectance;
	vec3 mirrorReflectance;
	float phongExponent;
};

struct Vertex
{
	vec3 pos;
};

struct Indices
{
	int a;
	int b;
	int c;
};

struct Triangle
{
	int materialId;
	Indices indices;
};

struct Mesh
{
	int materialId;
	int indicesOffset;
	int indicesSize;
	int rootBVHNode;
};

struct Sphere
{
	int centerVertexId;
	int materialId;
	float radius;
};

struct Camera
{
	vec3 position;
	vec3 gaze;
	vec3 up;
	vec3 v;
	vec4 nearPlane;
	vec2 imageResolution;
	float nearDistance;
};


struct Ray
{
	vec3 origin;
	vec3 direction;
};

struct IntersectionReport
{
	vec3 intersection;
	vec3 normal;
	float d;
	int materialId;

	int dbg;
};

struct BoxReport
{
	int id;
	vec3 point;
	int dbg;
};

struct AABB
{
	float xmax;
	float ymax;
	float zmax;
	float xmin;
	float ymin;
	float zmin;
};

struct BVHNode
{
	AABB aabb;
	int leftNode;
	int rightNode;
	int indicesOffset;
	int indicesSize;
};

// -------------------------------------------------------------- //
#define FLT_MAX 3.402823466e+38
#define FLT_MIN 1.175494351e-38
// ------------------- UNIFORMS -------------------------- //

uniform vec3 backgroundColor;
uniform vec3 ambientLight;
uniform Camera camera;
uniform int maxRecursionDepth;
uniform float shadowRayEpsilon;
uniform float intersectionTestEpsilon;


uniform int lightCount;
uniform int materialCount;
uniform int vertexCount;
uniform int meshCount;
uniform int meshIndexCount;
uniform int triangleCount;
uniform int sphereCount;

// -------------------------------------------------------------- //

// -------------- SHADER STORAGE BUFFER OBJECTS ----------------- //

layout(std430, binding=3) buffer lights
{
	PointLight pointLights[];
};

layout(std430, binding=4) buffer mtrls
{
	Material materials[];
};

layout(std430, binding=5) buffer vrtxdata
{
	Vertex vertexData[];
};

layout(std430, binding=6) buffer mshs
{
	Mesh meshes[];
};

layout(std430, binding=7) buffer tris
{
	Triangle triangles[];
};

layout(std430, binding=8) buffer sphrs
{
	Sphere spheres[];
};

layout(std430, binding=9) buffer cmrs
{
	Camera cameras[];
};

layout(std430, binding=10) buffer mshIndices
{
	Indices meshIndexBuffer[];
};

layout(std430, binding=11) buffer mshNormals
{
	Vertex meshNormals[];
};

layout(std430, binding=12) buffer bvhIndices
{
	Indices BVHIndices[];
};

layout(std430, binding=13) buffer bvhNodes
{
	BVHNode BVHNodes[];
};

// -------------------------------------------------------------- //

// ------------------------- DEFINITIONS ------------------------ //

#define MAX_RECURSION_DEPTH 100

// -------------------------------------------------------------- //

// -------------------------- GLOBALS --------------------------- //
/*
	if(fabs(someFloat - 1.0) < 0.000001)
	{

	}

*/

float tmin = 0;
float tmax = 1000;

BVHNode nodeStack[MAX_RECURSION_DEPTH];
Ray     rayStack[MAX_RECURSION_DEPTH];
// -------------------------------------------------------------- //


// -------------------- FUNCTIONS ------------------------------- //


Ray computePrimaryRay(ivec2 pixelCoords)
{

	Ray x;
	x.origin = camera.position;
	vec3 m = x.origin + camera.gaze * camera.nearDistance;
	vec3 q = m + camera.nearPlane.x * camera.v + camera.nearPlane.w * camera.up;

	float su = (pixelCoords.x + 0.5) * (camera.nearPlane.y - camera.nearPlane.x) / camera.imageResolution.x;
	float sv = (pixelCoords.y + 0.5) * (camera.nearPlane.w - camera.nearPlane.z) / camera.imageResolution.y;

	x.direction = normalize((q + su*camera.v - sv*camera.up) - x.origin);
	return x;
}

// This function tests intersection between a ray and a sphere
IntersectionReport intersectSphere(Ray r, Sphere s, float tmin, float tmax)
{
	IntersectionReport report;
	report.dbg = 0;

	report.intersection = vec3(FLT_MIN);
	report.d = FLT_MAX;

	vec3 sphereCenter = vertexData[s.centerVertexId - 1].pos;

	float discriminant = pow(dot(r.direction, (r.origin - sphereCenter)),2) - 
	                     dot(r.direction,r.direction)*(dot(r.origin - sphereCenter, r.origin - sphereCenter) - 
						                               s.radius * s.radius);
	
	float t;

	if(discriminant >= 0)
	{
		float t1 = -(dot(r.direction, (r.origin - sphereCenter)) + sqrt(discriminant)) / dot(r.direction, r.direction);
		float t2 = -(dot(r.direction, (r.origin - sphereCenter)) - sqrt(discriminant)) / dot(r.direction, r.direction);

		t =  min(t1, t2);

		if(t > tmin && t < tmax)
		{
			report.d = t;
			report.intersection = r.origin + t*r.direction;
			report.materialId = s.materialId;
			report.normal = normalize(report.intersection - sphereCenter);
		}

		
		return report;
	}


	return report;
}


BoxReport intersectBox(Ray r, AABB box, float tmin, float tmax)
{

	BoxReport rprt;

	float t1x = clamp((box.xmin - r.origin.x) / r.direction.x, tmin, tmax);
	float t2x = clamp((box.xmax - r.origin.x) / r.direction.x, tmin, tmax);

	if(t1x > t2x)
	{
		float tmp = t1x;
		t1x = t2x;
		t2x = tmp;
	}

	float t1y = clamp((box.ymin - r.origin.y) / r.direction.y, tmin, tmax);
	float t2y = clamp((box.ymax - r.origin.y) / r.direction.y, tmin, tmax);

	if(t1y > t2y)
	{
		float tmp = t1y;
		t1y = t2y;
		t2y = tmp;
	}

	float t1z = clamp((box.zmin - r.origin.z) / r.direction.z, tmin, tmax);
	float t2z = clamp((box.zmax - r.origin.z) / r.direction.z, tmin, tmax);

	if(t1z > t2z)
	{
		float tmp = t1z;
		t1z = t2z;
		t2z = tmp;
	}

	float t1max = t1x;
	float t2min = t2x;

	if(t1max < t1y)
		t1max = t1y;
	if(t1max < t1z)
		t1max = t1z;

	if(t2min > t2y)
		t2min = t2y;
	if(t2min > t2z)
		t2min = t2z;

	if(t1max > t2min)
	{	
		rprt.id = -1;
		return rprt;
	}
	else if(t1max < t2min)
	{
		float dist = distance(r.origin + t1max*r.direction, r.origin + t2min*r.direction);
		if(dist < 0.06)
			rprt.id = 0;
		else
			rprt.id = 1;
		return rprt;
	}
	else if(t1max == t2min)
	{
		rprt.id = 1;
		return rprt;
	}
	else
	{
		rprt.id = -1;
		return rprt;
	}

}

IntersectionReport MollerTrumboreIntersection(in Ray r, in Indices indices, float tmin, float tmax)
{
	IntersectionReport report;
	report.intersection = vec3(FLT_MIN);
	report.d = FLT_MAX;
	report.dbg = 0;	

	vec3 v0 = vertexData[indices.a - 1].pos;
	vec3 v1 = vertexData[indices.b - 1].pos;
	vec3 v2 = vertexData[indices.c - 1].pos;
	vec3 edge1, edge2, h, s, q;
	float a, f, u, v;

	edge1 = v1 - v0;
	edge2 = v2 - v0;

	h = cross(r.direction, edge2);
	a = dot(edge1, h);

	if(a > -intersectionTestEpsilon && a < intersectionTestEpsilon)
		return report;
	
	f = 1.0 / a;
	s = r.origin - v0;
	u = f * dot(s, h);

	if(u < 0.0 || u > 1.0)
		return report;

	q = cross(s, edge1);
	v = f * dot(r.direction, q);

	if(v < 0.0 || u + v > 1.0)
		return report;

	float t  = f * dot(edge2, q);

	if(t > intersectionTestEpsilon && t>tmin && t<tmax)
	{
		report.intersection = r.origin + r.direction * t;
		report.d = t;
	}
	

	return report;
}

// This function tests intersection between a ray and a triangle
IntersectionReport intersectFace(in Ray r, in Indices indices, float tmin, float tmax)
{
	IntersectionReport report;
	report.intersection = vec3(FLT_MIN);
	report.d = FLT_MAX;	
	report.dbg = 0;		

	vec3 a = vertexData[indices.a - 1].pos;
	vec3 b = vertexData[indices.b - 1].pos;
	vec3 c = vertexData[indices.c - 1].pos;

	float detA = determinant(mat3(vec3(a.x - b.x, a.y - b.y, a.z - b.z),
	                              vec3(a.x - c.x, a.y - c.y, a.z - c.z),
								  vec3(r.direction.x, r.direction.y, r.direction.z)));


	float beta = determinant(mat3(vec3(a.x - r.origin.x, a.y - r.origin.y, a.z - r.origin.z),
	                              vec3(a.x - c.x, a.y - c.y, a.z - c.z),
								  vec3(r.direction.x, r.direction.y, r.direction.z)))/detA;

	float gamma = determinant(mat3(vec3(a.x - b.x, a.y - b.y, a.z - b.z),
	                               vec3(a.x - r.origin.x, a.y - r.origin.y, a.z - r.origin.z),
								   vec3(r.direction.x, r.direction.y, r.direction.z)))/detA;


	float t = determinant(mat3(vec3(a.x - b.x, a.y - b.y, a.z - b.z),
	                           vec3(a.x - c.x, a.y - c.y, a.z - c.z),
							   vec3(a.x - r.origin.x, a.y - r.origin.y, a.z - r.origin.z)))/detA;


	if((beta + gamma <= 1 + intersectionTestEpsilon) && (beta >= -intersectionTestEpsilon) && (gamma >= -intersectionTestEpsilon) && t>tmin && t<tmax)
	{
		report.d = t;
		report.intersection = r.origin + t*r.direction;		
	}

	return report;
}

IntersectionReport intersectTriangle(Ray r, Triangle triangle)
{
	IntersectionReport report = MollerTrumboreIntersection(r, triangle.indices, tmin, tmax);
	report.materialId = triangle.materialId;

	vec3 a = vertexData[triangle.indices.a-1].pos;
	vec3 b = vertexData[triangle.indices.b-1].pos;
	vec3 c = vertexData[triangle.indices.c-1].pos;

	report.normal = normalize(cross(b-a, c-a));


	return report;
}

IntersectionReport intersectMesh(Ray r, Mesh mesh)
{
	float tMin = FLT_MAX;

	IntersectionReport report;
	report.intersection = vec3(FLT_MAX);
	report.d = tMin;	
	report.materialId = mesh.materialId;

	BoxReport aabbIntersect = intersectBox(r, BVHNodes[mesh.rootBVHNode].aabb, tmin, tmax);

	if(aabbIntersect.id == 1)
	{
		report.dbg = 0;
		for(uint i= mesh.indicesOffset; i<mesh.indicesSize; i++)
		{
			IntersectionReport rprt = intersectFace(r, meshIndexBuffer[i], tmin, tmax);

			if(rprt.d < tMin)
			{
				report.intersection = rprt.intersection;
				report.normal = meshNormals[i].pos;
				report.d = rprt.d;
				tMin = report.d;
			}
		}
	}

	else if(aabbIntersect.id == 0)
	{
		report.dbg = 1;
		report.d = 1000;
	}



	return report;	
}

IntersectionReport intersectBVH(Ray r, BVHNode rootNode)
{
	IntersectionReport report;

	float tMin = FLT_MAX;

	// Initialize stack with root node
	nodeStack[0] = rootNode;
	int stackPointer = 1;

	while(stackPointer >= 1)
	{
		
	}

	return report;
}

IntersectionReport testWorldIntersection(Ray primaryRay)
{
	float tMin = FLT_MAX;
	IntersectionReport report;
	report.intersection = vec3(FLT_MAX);
	report.d = FLT_MAX;	

	
	for(uint i=0; i<meshCount; i++)
	{
		IntersectionReport r = intersectMesh(primaryRay, meshes[i]);
		if(r.d < tMin)
		{
			report = r;
			tMin = r.d;
			if(r.dbg == 1)
				report.dbg = 1;
		}
	}
	

	
	for(uint i=0; i<triangleCount; i++)
	{
		IntersectionReport r = intersectTriangle(primaryRay, triangles[i]);
		if(r.d < tMin)
		{
			report = r;
			tMin = r.d;
		}		
	}
	
	
	
	for(uint i=0; i<sphereCount; i++)
	{
		IntersectionReport r = intersectSphere(primaryRay, spheres[i], tmin, tmax);
		if(r.d < tMin)
		{
			report = r;
			tMin = r.d;
		}
	}
	
	

	return report;
}

bool shadowRayIntersection(Ray ray, float dist)
{
	float tMin = FLT_MAX;
	IntersectionReport report;
	report.intersection = vec3(FLT_MAX);
	report.d = FLT_MAX;

	for(uint i=0; i<meshCount; i++)
	{
		IntersectionReport r = intersectMesh(ray, meshes[i]);
		if(r.d < dist)
		{
			return true;
		}
	}
	

	
	for(uint i=0; i<triangleCount; i++)
	{
		IntersectionReport r = intersectTriangle(ray, triangles[i]);
		if(r.d < dist)
		{
			return true;
		}		
	}
	
	
	
	for(uint i=0; i<sphereCount; i++)
	{
		IntersectionReport r = intersectSphere(ray, spheres[i], tmin, tmax);
		if(r.d < dist)
		{
			return true;
		}
	}

	return false;

}

vec3 computeAmbientComponent(IntersectionReport report)
{
	return ambientLight * materials[report.materialId - 1].ambientReflectance;
}

vec3 computeDiffuseComponent(IntersectionReport report, PointLight light)
{
	vec3 result = vec3(0.0);

	float lightDistance = length(light.position - report.intersection);
	vec3 wi = normalize(light.position - report.intersection);
	result += materials[report.materialId - 1].diffuseReflectance * 
		      max(0,dot(wi, report.normal)) * 
			  (light.intensity/(lightDistance*lightDistance));

	return result;
}

vec3 computeSpecularComponent(IntersectionReport report, Ray primaryRay, PointLight light)
{
	vec3 result = vec3(0.0);


	float lightDistance = length(light.position - report.intersection);		
	vec3 wi = normalize(light.position - report.intersection);
	vec3 h = normalize(wi - primaryRay.direction);

	result += materials[report.materialId - 1].specularReflectance *
		      pow(max(0, dot(report.normal, h)), materials[report.materialId -1].phongExponent) *
			  (light.intensity/(lightDistance*lightDistance));				  



	return result;
}

bool shadowTest(IntersectionReport report, PointLight light)
{
	Ray lightRay;

	lightRay.direction = normalize(light.position - report.intersection);
	lightRay.origin = report.intersection + shadowRayEpsilon*report.normal;

	float dist = length(light.position - report.intersection);


	return shadowRayIntersection(lightRay, dist);

}

vec3 computeFinalColor(IntersectionReport report, Ray primaryRay)
{
	vec3 result = computeAmbientComponent(report);

	for(uint i=0; i<lightCount; i++)
	{
		if(shadowTest(report, pointLights[i]))
		{
			continue;
		}
		else
		{
			result += computeDiffuseComponent(report, pointLights[i]) + 
			          computeSpecularComponent(report, primaryRay, pointLights[i]);
		}
	}

	return clamp(result, vec3(0.0), vec3(1.0));
}


// -------------------------------------------------------------- //
void main()
{
	ivec2 size = imageSize(imgOutput);

	// base pixel color for image
	vec4 pixel = vec4(backgroundColor, 1.0);

	// get index in global work group i.e x,y position
	ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);

	Ray primaryRay = computePrimaryRay(pixelCoords);
	IntersectionReport report = testWorldIntersection(primaryRay);


	if(report.d != FLT_MAX)
	{
		pixel = vec4(computeFinalColor(report, primaryRay), 1.0);

		if(report.dbg == 1)
			pixel = vec4(0.5, 0.0, 1.0, 1.0);
	}
	else
	{
		pixel = vec4(backgroundColor, 1.0);
	}
	
	if(pixelCoords.x == 0 && pixelCoords.y == size.y - 1)
	{



		pixel = vec4(BVHNodes[0].leftNode, BVHNodes[0].rightNode, BVHNodes[0].aabb.zmin, 1.0);

	}
	

	//
	// TODO: IMPLEMENT HERE
	//

	// output to a specific pixel in the image
	imageStore(imgOutput, ivec2(pixelCoords.x, size.y - pixelCoords.y -1), pixel);
}